[TOC]

# 检错和纠错

## 码距
> 在编码系统中，任意两个码字的最小距离
> 增大码距，可用于检查错误和纠正错误

* 1个长度的二进制编码，A=1，B=0，则AB之间的最小码距为1
* 2个长度的二进制编码，A=11，B=00，则AB之间的最小码距为2
* 3个长度的二进制编码，A=111，B=000，则AB之间的最小码距为3

## 码距对检错和纠错的影响
* **以1个长度为例**
> 假设A传错了，变成0；因为1和0都是合法，所以并不知道是否错误了

* **以2个长度为例**
> 假设A传错了，变成10；虽然知道10是不合法的，但无法纠错：因为接收端可能认为原值是11，也可能是00

* **以3个长度为例**
> 假设A传错了，变成110；检错和纠错都能正常进行：110是不合法的，因跟111相近，所以纠正为111

## 确定码距的合适值
1. 码组中，为了检测x个误码，码距必须满足：>=x+1
2. 码组中，为了纠正x个误码，码距必须满足：>=2x+1

# 校验码
> 需要补充学习：二进制除法
> 除数大于当前位的除数，才能进行相除，否则被除数进位
* 除法是每一步做减法
* 模2除法是每一步做异或

> **除法**

基于以下规则（看减法即可）：
![[Pasted image 20220210130948.png]]
例子：10111/110
![[绘图/二进制除法.md]]

> 模2除法
![[绘图/模2除法.md]]

## 循环校验码CRC
<<<<<<< HEAD
> 原理：带有CRC校验码的数据报文（二进制形式），传到接收端，接收端接收到后，如果该数据可以整除生成多项式数据（二进制形式），则认为数据在传输过程没有出错

**举个例子：原始报文：11001010101，生成多项式为`x^4+x^3+x+1`，请CRC编码后的结果**

1. `x^4+x^3+x+1`需要换算为二进制形式
 
> 方法是指数分别对应到位上，x^4为第5位、x^3为第4位、x为第2位、1为第1位；缺少第3位，给0。所以最终值为：**11011**

^614368

2. 计算校验码的位数

> 需要用到[[#^614368]]的值：11011，总位数是5，减1作为校验码的位数：4。

3. 开始计算
![[绘图/循环校验码CRC的计算逻辑.md]]

## 海明校验码
根据信息位的个数，总位数是信息位个数+比信息位小的校验位总数。

确定校验位的个数的条件：`2^r = x + r + 1（x为信息位个数，r为校验位数）`，r校验位数必须小于等于2^r。 ^f945ff

**举个例子：原始报文：1011，求海明码**
1. 原始报文个数为4（即x=4），通过公式[[#^f945ff]]，得知r=3，才满足条件。**因此校验位总数为3：2^0=1、2^1=2、2^2=4，分别占据第1位、第2位、第4位**

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 位数 |
| --- | ---| --- | ---| ---| ---| ---| --- |
| I4 | I3 | I2 |  | I1  |   |   | 信息位 |
|  |  |  | r2 |  | r1 | r0 | 校验位 |

2. 接下来算各个校验位的数目是多少
上一步已经确定信息位和校验位在哪，信息位分别占据7、6、5、3
![[绘图/海明校验码.md]]
=======

## 检错和纠错
![[绘图/海明校验码-检错和纠错.md]]
>>>>>>> 2b438e0b9c7c417fb0308237dbc010823eddba91
