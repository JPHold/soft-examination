[TOC]

# 算法的特性
* **有穷性**
> 都有尽头，执行有穷步之后，会终止运算

* **确定性**
> 相同入参等条件， 结果都是一样的

* **输入参数个数和输出结果个数**
> 输入参数个数可有可无
> 输出结果至少有一个

* **有效性**
> 每个步骤的都能有效执行并得到确定的结果，比如0不能当除数

# 算法的复杂度
主要考时间复杂度，下午的设计题出现[[重点]]

* **算法中，有多个操作，取最大的复杂度**

## 时间复杂度
$O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n)$


* **常数集，都用O(1)，比如i=1**

* **$O(log_2n)$是二叉树的查找算法，n为这个树的层数，查找某个结点，最坏的情况是查找n次。比如n为8，则结果为3次**

* **$O(n)$为一次循环、**$O(n^2)$为两次循环（嵌套循环）、**$O(n^3)$为三次循环（嵌套循环）**
 
## 空间复杂度


# 查找
## 顺序查找
> 按顺序一个个比较
> 比如`[1，2，3，4，5，6，7，8]`，最快1次就可以找到；最慢8次才找到

* **平均长度是$\dfrac{(1+2+3+...+n)}{n}$=$\dfrac{n+1}{2}$**
**因为最大影响操作是n，所以时间复杂度：O(n)**

![[Pasted image 20220416101302.png]]

## 二分查找
### 算法思想
* **前提**
1. 必须是排序的序列

* **查找规则**
1. 当前下标范围的最小数和最大数，相加并除以2。mid=$\dfrac{(low+high)}{2}$，mid向下取整（比如6.1、6.9，都取6）
2. 判断当前查找数（记作x）是否等于mid，相等则查找成功，否则继续下一步的二分查找
3. 如果x小于mid，则查找范围落在`[low，mid-1]`，记作`[low，high]`，则重复第1、2、3、4、5步
4. 如果x大于mid，则查找范围落在`[mid+1，high]`，记作`[low，high]`，则重复第1、2、3、4、5步
5. 如果high小于low 或 low 大于 high，则查找失败，结束算法

![[Pasted image 20220416101246.png]]

![[Pasted image 20220416101254.png]]

![[Pasted image 20220416114246.png]]

## 散列表
> 利用散列函数，计算存放的位置
> 如果已被占用，则解决冲突，有两种方式
1. 线性探测法
> 判断后面位置有没有被占用，直到找到没占用的位置

2. 伪随机数法

* **当然不采用这些方式也可以，加大存储空间、一个散列函数会冲突，那就计算多个散列函数，直到不冲突**
![[Pasted image 20220416114820.png]]

![[Pasted image 20220416114827.png]]

# 排序
## 概念
> **分为稳定与不稳定排序、内排序与外排序**

* **稳定与不稳定排序是相同的数，经过排序，顺序没有变。比如红色21在黑色21之前**
* **内排序与外排序是采用什么介质来执行排序，比如内存、外存**

## 方法
| 分类     | 名称         | 描述                                                                               |
| -------- | ------------ | ---------------------------------------------------------------------------------- |
| 插入类   | 直接插入排序 | 每次插入，都要与队列的所有数，进行一一对比，找到所属位置，保证顺序（比如从小到大） |
|          | 希尔排序     |                                                                                    |
| 交换类   | 冒泡排序     |                                                                                    |
|          | 快速排序     |                                                                                    |
| 选择类   | 简单选择排序 |                                                                                    |
|          | 堆排序       |                                                                                    |
| 归并排序 |              |                                                                                    |
| 基数排序 |              |                                                                                    |

### 直接插入排序
* **有这些数：57、68、59、52，要从小到大排序**
1. 插入57
2. 插入68，大于57，排在后面：**57、68**
3. 插入59，小于68，往前挪；大于57，排在后面：**57、59、68**
4. 插入52，小于68，往前挪；小于59，往前挪；小于57，排在前面：**52、57、59、68**

![[Pasted image 20220416162352.png]]

### 希尔排序
> 先分组，再[[#直接插入排序]]

1. 取一个小于n的整数（取奇数）（采用何种算法，都可以），记作d1
2. 将距离为d1的倍数的数，归为一组，执行直接插入排序
3. 继续第1、2步骤，直到d1<=1结束分组，执行最后一次直接插入排序

![[Pasted image 20220416175450.png]]

![[Pasted image 20220416175501.png]]

### 直接选择排序
1. 取当前所有数的最小数，跟第一个数做交换
2. 然后在剩余所有数中，继续找出最小数，跟第二个数做交换
3. 以此类推，直到最后一个，才结束

![[Pasted image 20220416180318.png]] 

### 堆排序
* **首先满足完全二叉树**
* **分为小顶堆和大顶堆**
1. 小顶堆是所有子结点都比根结点大
2. 大顶堆是所有子结点都比根结点小

![[Pasted image 20220417113029.png]]

> [[重点]]考察将序列建堆：小顶堆或大顶堆、再进行堆排序，按从小到大或从大到小，逐一输出

#### 建堆
**以大顶堆为例**

1. 先从上到下，再从左到右，依次建立成完全二叉树
2. 选择所有非叶子结点，从最底层开始，进行大小判断，最大的结点上升为根结点，原先的根结点下沉，变成子结点
3. 如果第二步，原先的根结点变成子结点，并不是当前结构的最大结点，则继续重复第2、3步，直到整颗树的根结点

**第1步对应到图1.1 **

**第2步对应到图1.2、1.3、1.4**

**第3步对应到图1.4和1.5的圈住部分、图1.5和1.6的①结点跟⑧结点互换**

![[Pasted image 20220417113941.png]]

![[Pasted image 20220417113102.png]]

#### 排序
**前提是[[#建堆]]**

**以大顶堆为例**

1. 输出根结点
2. 将最后一个结点提到根结点
3. 重复[[建堆]]过程（有所不同，这里是从上到下重建），决择出最大根结点；重复第1、2、3步，直到所有结点输出完毕

![[Pasted image 20220417114809.png]]

### 冒泡排序

1. 从最后一个数开始
2. 与前一个数比较 
3. 小则交换位置，继续第2、3、4步
4. 大则无需交换位置，继续从最后一个较小的数开始，继续第2、3、4
5. 直到所有数都判断了一遍 

![[Pasted image 20220417171741.png]]

### 快速排序
**以从小到大为例子**
1. 从序列中任意选择一个数
2. 以这个数为基准，从左边或右边开始扫描（如果这个数在最左边，那就从右边开始扫描，在最右边，那就从左边开始扫描）
3. 已经比较过的数无须再比较，当前数比基准数小，则交换位置，反向扫描，重复第3步
4. 直到所有数都比较完，则左右两组数，分别排序，算法结束

![[Pasted image 20220418215226.png]]

### 归并排序
> 采用分治法

**以从小到大为例**
1. 以至少两个数为一组
2. 每个组内部进行排序，形成新的有序表
3. 排序完毕，两个组，继续合并一组，并排好序，形成成一个新的有序表。重复弟2、3步
4. 直到只有一个有序表，算法结束

![[Pasted image 20220417181518.png]]

### 基数排序
1. 分析所有数，找到共性的规律（多个）
2. 以这个规律，进行划分；相同规律的数，放到一个链上
3. 划分完毕后，铺平，继续第2、3步
4. 知道所有规律划分完毕

比如这些数都是十进制数，规律是有个位数、十位数、百位数。。。

![[Pasted image 20220418220128.png]]

## 复杂度
