[TOC]

# 算法的特性
* **有穷性**
> 都有尽头，执行有穷步之后，会终止运算

* **确定性**
> 相同入参等条件， 结果都是一样的

* **输入参数个数和输出结果个数**
> 输入参数个数可有可无
> 输出结果至少有一个

* **有效性**
> 每个步骤的都能有效执行并得到确定的结果，比如0不能当除数

# 算法的复杂度
主要考时间复杂度，下午的设计题出现[[重点]]

* **算法中，有多个操作，取最大的复杂度**

## 时间复杂度
$O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n)$


* **常数集，都用O(1)，比如i=1**

* **$O(log_2n)$是二叉树的查找算法，n为这个树的层数，查找某个结点，最坏的情况是查找n次。比如n为8，则结果为3次**

* **$O(n)$为一次循环、**$O(n^2)$为两次循环（嵌套循环）、**$O(n^3)$为三次循环（嵌套循环）**
 
## 空间复杂度


# 查找
## 顺序查找
> 按顺序一个个比较
> 比如`[1，2，3，4，5，6，7，8]`，最快1次就可以找到；最慢8次才找到

* **平均长度是$\dfrac{(1+2+3+...+n)}{n}$=$\dfrac{n+1}{2}$**
**因为最大影响操作是n，所以时间复杂度：O(n)**

![[Pasted image 20220416101302.png]]

## 二分查找
### 算法思想
* **前提**
1. 必须是排序的序列

* **查找规则**
1. 当前下标范围的最小数和最大数，相加并除以2。mid=$\dfrac{(low+high)}{2}$，mid向下取整（比如6.1、6.9，都取6）
2. 判断当前查找数（记作x）是否等于mid，相等则查找成功，否则继续下一步的二分查找
3. 如果x小于mid，则查找范围落在`[low，mid-1]`，记作`[low，high]`，则重复第1、2、3、4、5步
4. 如果x大于mid，则查找范围落在`[mid+1，high]`，记作`[low，high]`，则重复第1、2、3、4、5步
5. 如果high小于low 或 low 大于 high，则查找失败，结束算法

![[Pasted image 20220416101246.png]]

![[Pasted image 20220416101254.png]]

![[Pasted image 20220416114246.png]]

## 散列表
> 利用散列函数，计算存放的位置
> 如果已被占用，则解决冲突，有两种方式
1. 线性探测法
> 判断后面位置有没有被占用，直到找到没占用的位置

2. 伪随机数法

* **当然不采用这些方式也可以，加大存储空间、一个散列函数会冲突，那就计算多个散列函数，直到不冲突**
![[Pasted image 20220416114820.png]]

![[Pasted image 20220416114827.png]]

# 排序
## 概念
> **分为稳定与不稳定排序、内排序与外排序**

* **稳定与不稳定排序是相同的数，经过排序，顺序没有变。比如红色21在黑色21之前**
* **内排序与外排序是采用什么介质来执行排序，比如内存、外存**

# 方法
| 分类     | 名称         | 描述 |
| -------- | ------------ | ---- |
| 插入类   | 直接插入排序 |      |
|          | 希尔排序     |      |
| 交换类   | 冒泡排序     |      |
|          | 快速排序     |      |
| 选择类   | 简单选择排序 |      |
|          | 堆排序       |      |
| 归并排序 |              |      |
| 基数排序 |              |      |
