[TOC]

# 算法的特性
* **有穷性**
> 都有尽头，执行有穷步之后，会终止运算

* **确定性**
> 相同入参等条件， 结果都是一样的

* **输入参数个数和输出结果个数**
> 输入参数个数可有可无
> 输出结果至少有一个

* **有效性**
> 每个步骤的都能有效执行并得到确定的结果，比如0不能当除数

# 算法的复杂度
主要考时间复杂度，下午的设计题出现[[重点]]

* **算法中，有多个操作，取最大的复杂度**

## 时间复杂度
$O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n)$


* **常数集，都用O(1)，比如i=1**

* **$O(log_2n)$是二叉树的查找算法，n为这个树的层数，查找某个结点，最坏的情况是查找n次。比如n为8，则结果为3次**

* **$O(n)$为一次循环、**$O(n^2)$为两次循环（嵌套循环）、**$O(n^3)$为三次循环（嵌套循环）**
 
## 空间复杂度


# 查找
## 顺序查找
> 按顺序一个个比较
> 比如`[1，2，3，4，5，6，7，8]`，最快1次就可以找到；最慢8次才找到

* **平均长度是$\dfrac{(1+2+3+...+n)}{n}$=$\dfrac{n+1}{2}$**
**因为最大影响操作是n，所以时间复杂度：O(n)**

## 二分查找
## 算法思想
* **前提**
1. 必须是排序的序列

* **查找规则**
1. 当前范围的最小数和最大数，相加并除以2。mid=$\dfrac{(low+high)}{2}$
2. 判断当前查找数（记作x）是否等于mid，相等则查找成功，否则继续下一步的二分查找
3. 如果x大于mid，则查找范围落在`[low，mid-1)`，则继续