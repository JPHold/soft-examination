[TOC]

# 数据结构
![[Pasted image 20220407213257.png]]
 > 图有环路，从部分来看，包含线性结构和树
 > 树，假如只有一个子节点，那么也是线性结构

# 数组与矩阵

## 数组
### 计算某个位置的存储地址
> 数组a，则开始存储地址为a
> 记每个元素所占字节为len

* **一维数组：`a[i]`**
**公式：**`a + i * len` 

* **二维数组：`a[m][n]`**
> 按存储方式不同，计算公式不同

**按行存储：**
公式：`a + (i * n + j) * len `

**按列存储：**
公式：`a + (j * m + i) * len`

**解释一下：**
* **按行存储，从左到右摆满后，再切换到下一行，继续从左到右**
所以得出当前位置是第几个，就需要数一行有多少个（**也就是多少列，即看n**）

* **按列存储，从上到下摆满后，再切换到下一列，继续从上到下**
> 所以得出当前位置是第几个，就需要数有多少行（**即看m**），是相反计算

* **下标从0开始，所以直接乘以个数即可     **

## 矩阵
### 稀疏矩阵
> 元素为0代表无效数据或重复数据

![[Pasted image 20220407212625.png]]
* **作用**
> 是否可以只用到一部分矩阵，就将有效数据存进去
> 比如图片，有重复部分，那么只要存储有效数据即可，剩下

* **考察矩阵的某个位置，换算到一维数组中，是哪个位置**
> 无须记上面那张图的公式，可以直接使用代入法
![[Pasted image 20220407212850.png]]


# 线性表
### 顺序表
* **连续空间**

### 链表
* **离散空间，使用指针相连**
> 考察删除、添加节点，指针的指定

#### 单链表
> 有无头节点，是不一样
> 头节点不存在任何数据，是为了保持一致的处理

#### 循环链表


#### 双向链表

### 顺序表与链表的对比
**需理解算法复杂度**[[不懂]]
[# 什么是算法复杂度](https://blog.csdn.net/icolakele/article/details/100167755?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&utm_relevant_index=1)
> 复杂度，是基于操作中，影响最大的执行部分：比如f(x) = 3x^3 + 2x + 10，当x越大，f(x)和3x^3，就趋近于相等，所以复杂度O(f(x))是等于O(3x^3)

| 性能类别 | 指标     | 顺序存储                         | 链式存储                             |
| -------- | -------- | -------------------------------- | ------------------------------------ |
| 空间性能 | 存储密度 | =1，更忧                         | <1                                   |
|          | 容量分配 | 事先确定                         | 动态分配                             |
| 时间性能 | 查找运算 | O(n/2)                           | O(n/2)                               |
|          | 读运算   | O(1)，更忧                       | O([n+1]/2)，最好情况为1，最坏情况为n |
|          | 插入运算 | O(n/2)，最好情况为1，最坏情况为n | O(1)，更优                           |
|          | 删除运算 | O([n-1]/2)                       | O(1)，更优                           |

## 栈和队列
* **循环队列**
> tail为当前位置（尾指针），head为开头位置
> 如果全部都占满，那么最后一个元素，他的tail指向0（也就是head），那么就无法区分是队空还是队満
> 因此公式如下：
1. 队空：`tail == head`
2. 队満：`(tail+1) % size == head`

![[Pasted image 20220409111357.png]]
> 依次进入即可解答

**答案：D**

# 广义表
> [[#线性表]]的推广
> 记作LS=(a0, a1, ..., an)，an可以是数据元素，也可以是子表，每个子表又可以包含数据元素或子表，如此嵌套下去。
> [[重点]]，考察长度和深度，而长度是最外层的元素个数，深度是嵌套的深度

![[Pasted image 20220409113011.png]]

**例2的答案：head(head(tail(LS1)))**

# 树与二叉树
## 属性概念
| 属性     | 描述                                           |
| -------- | ---------------------------------------------- |
| 结点的度 | 某个结点有多少个子结点                         |
| 树的度   | 基于结点的度，取最大数                         |
| 叶子结点 | 没有子结点的结点                               |
| 分支结点 | 有子结点的结点                                 |
| 内部结点 | 上有父节点，下有子结点的节点（夹在中间的结点） |
| 父结点   | 有子结点的结点                                 |
| 子结点   | 有父结点的结点                                 |
| 兄弟结点 | 同级结点                                       |
| 层次     | 深度                                           |
![[数据结构与算法基础-属性概念]]

## 二叉树的种类
| 类型         | 描述 |
| ------------ | ---- |
| 満二叉树     | 每个结点都有两个子结点（**也就是结点的度都为2**）     |
| 完全二叉树   | 除了底层，其它层都是満的，并且从左到右，中间都没有缺，只有右侧没有満     |
| 非安全二叉树 | 有两种情形：1、除了底层，其它层都是満的，并且从左到右，中间有缺；2、除了底层，其它层没有満     |

![[数据结构与算法基础-二叉树的分类]]


## 二叉树的规律和特性
1. 在二叉树的第i层上最多有2^(i-1)个结点（i>=1）;
2. 深度为k的二叉树最多有2^(k) - 1个结点（k>=1）;
3. 对任何一棵二叉树，如果其叶子结点数为n0，度为2的结点数为n2，则n0=n2+1。
4. 如果对一棵有n个结点的完全二叉树的结点按层序编号(从第1层到log2n+1层，每层从左到右),则对任一结点i (1<= i <= n)，有如下规律:
✔如果i=1，则结点i无父结点，是二叉树的根；如果i>1，则父结点是i/2;
✔如果2i>n，则结点i为叶子结点，无左子结点；否则，其左子结点是结点2i;
✔如果2i+1>n，则结点i无右子叶点，否则，其右子结点是结点2i+1。


## 二叉树操作
### 遍历
| 类型     | 描述 |
| -------- | ---- |
| 前序遍历 | 顺序：根左右      |
| 中序遍历 | 顺序：左根右     |
| 后序遍历 | 顺序：左右根     |
| 层次遍历         | 从上到下，从左到右，依次     |
![[数据结构与算法基础-二叉树遍历]]

#### 反向构造二叉树
> 从 序列，反向形成二叉树

* **解题思路（比较麻烦，而且很容易错）[[重点]]**
![[Pasted image 20220410111933.png]]


### 树转二叉树
> 有两种方法

![[Pasted image 20220410113536.png]]

* **逐个分析法**
1. 孩子结点，都放到左子树结点，**存在多个孩子结点，则取最左边结点为根结点**
2. 多个兄弟结点，**最左边结点为根结点，最近一个的节点为右孩子结点**

* **直接连线+旋转**

## 二叉树的细分
| 名称                   | 描述                                                                                             | 优点                             | 缺点 |
| ---------------------- | ------------------------------------------------------------------------------------------------ | -------------------------------- | ---- |
| 查询二叉树             | 左侧结点都比根结点小，右侧结点都比根结点大                                                       |                                  |      |
| 最优二叉树（哈夫曼树） | 是一个工具，用于哈夫曼编码（压缩编码方式，将原始信息的编码长度变短），多媒体的压缩技术中经常用到 | 节省存储空间和传输带宽、无损压缩 |      |
|                        |                                                                                                  |                                  |      |

### 查找二叉树
> 左侧结点都比根结点小，右侧结点都比根结点大，称为查找二叉树或排序二叉树

* **不允许相同值的结点**

**考察插入结点和删除结点，二叉树的重新分布（删除结点会麻烦一些76）[[重点]]**
![[Pasted image 20220410115044.png]]

### 最优二叉树（哈夫曼树）

![[Pasted image 20220410191341.png]]
#### 概念
* 树的路径长度
所有子结点到根结点的长度，累加，即为长度

* 权
叶子结点中的数，代表某个字符出现的频度（叫权值）

[[重点]] 为什么只有叶子结点才有权，因为只有叶子结点的数才是真实存在，其它中间结点都是这些叶子结点的数加起来，形成的新数，他们并不是原本真实存在

* **带权路径长度**
当前叶子结点的长度 * 他的权值 ^07e339

比如②这个叶子结点，他的长度是`1+1=2`，权值是2（圆圈上的数字），那么他的带权路径长度是`2*2=4`
![[Pasted image 20220514202746.png]]

* **树的带权路径长度（树的代价）**
分别计算每个叶子结点的带权路径长度[[#^07e339]]，加起来即可


***
#### 特性

1. 子结点相加，等于他们父结点的数

2. 所有的叶子结点的数，就等于所有的权值

3. 每个节点的度只能为 2 或者 0；

2. 叶子结点数是 N 时，中间节点数为 N-1，总结点数为 2*N-1

3. 任意一个叶节点的编码都不是其他叶节点编码的前缀。

4. 哈夫曼树应用于编码（左小右大）

#### 考察从一堆权值，构建哈夫曼树
> **要保证树的带权路径长度最小**

* 基于如下方式
1. 先将这些权值排序 ^31c8a6
2. 每次取最小的两个权值，形成新结点
3. 新结点加入下次权值排序，重复[[#^31c8a6]]
4. 直到所有结点都构建完毕

比如5、29、7、8、14、23、3、11
1. 排序后
3、5、7、8、11、14、23、29

2. 先3和5，形成结点8
新顺序：7、[8]、8、11、14、23、29

3. 7和结点8组合，形成结点15
新顺序：8、11、14、[15]、23、29

4. 8和11组合，形成结点19
新顺序：14、[15]、[19]、23、29

5. 14和15结点组合，形成结点29
新顺序：[19]、23、[29]、29

6. 19结点和23组合，形成结点42
新顺序：[29]、29、[42]

7. 29结点与29组合，形成结点58
新顺序：[42]、[58]

8. 42结点与58结点组合，形成结点100

**过程图**：
![[数据结构-构造哈夫曼树]]

#### 根据哈夫曼编码，构造哈夫曼树，并根据编码找到对应字符序列
![[Pasted image 20220515115707.png]]
**构建出来哈夫曼树：**
貌似是左结点小，右结点大；
同时左边为0，右边为1，根据这一点，就可以知道编码怎么排列了

* bee这个字符序列
b这个字符，经过的路径是55jia

![[数据结构-构造哈夫曼树并找出字符序列]]

## 线索二叉树

* **为何需要线索二叉树**
> 需要结点没有子结点，导致浪费需要空的指针；为了方便遍历

* **使用虚线表示线索**
* **二叉树转化成线索二叉树，是先按前序、中序、后序先列好，然后标识出当前结点的前继结点和后继结点**

![[Pasted image 20220411185402.png]]


## 平衡二叉树
* **规则**
1. 任意结点的左右子树的深度差不能超过1，也就是平衡度只能为-1、0、1

* **好处**
1. 结合排序二叉树的规则（左结点比根结点小，右结点比根结点大），减少遍历深度


# 图
![[Pasted image 20220412111237.png]]

| 名称   | 描述                                     |
| ------ | ---------------------------------------- |
| 无向图 | 顶点之间只有一条边相连                   |
| 有向图 | 顶点之间可以有两条有向边相连（相反方向） |

### 如何存储
> 利用邻接矩阵和邻接表来表示

#### 邻接矩阵
> 类似多维数组，第i行第j个为1，则代表i顶点跟j顶点相连，为0则不相连

![[Pasted image 20220412111929.png]]

* **上面图是无向图的例子，发现对角线都为0，对称的，所以存储时可以只存上三角或下三角**


#### 邻接表
> 先用数组存储每个顶点，再用链表，存储相连顶点和其距离

![[Pasted image 20220412112726.png]]


## 遍历
* **遍历方法**
> 深度是先走完左边顶点，再逐一回到上层，遍历右边顶点
> 广度是将走完同级的顶点，再走下一层（相当于从上到下，从左到右）
![[Pasted image 20220412113958.png]]

### 通过链表，分析
![[Pasted image 20220412161848.png]]



* **广度**
1. 先画出无向图
2. 在结合链表指向，确定遍历顺序
> 从v0开始，先访问当前链表的每个顶点
> 在再依次进入每个顶点的链表，访问当前链表的每个顶点，不会深入，立马退出

> 比如上图是第一次v0：0、4、3、1；第二次v4：6；第三次v3：无；第四次v1：2；第五次v6：7；第六次v2：5

结果：**0、4、3、1、6、2、7、5**

* **深度**
1. 先画出无向图
2. 在结合链表指向，确定遍历顺序、
> 从v0开始，到某个顶点，就必须进入二次遍历

> 比如上图第一次v0；第二次v4：6、7；第三次：v3：无；第四次v1：2、5

结果：**0、4、6、7、1、2、5**


##  拓扑排序
> 通过有向图和先后顺序，形成序列
> 箭头指向下一个顶点，则说明该顶点依赖上一个顶点

![[Pasted image 20220413221126.png]]


## 形成最小生成树
**树不能出现环路，也就是顶点只能接受一条边相连**
**有两种方法**

### 普利姆算法
1. 随便选择一个顶点
2. 将该顶点纳入决择区
3. 找到离这个顶点最近的顶点，并加入决择区
4. 遍历决择区的所有顶点，找到离他们最近的顶点，重复第3步和第4步，直到所有顶点都连起来

![[Pasted image 20220413223035.png]]

### 克鲁斯卡尔算法
1. 按最小距离的边，逐渐连接起来即可

![[Pasted image 20220413223051.png]]



# 排序与查找
* **时间复杂度**
* **空间复杂度**
