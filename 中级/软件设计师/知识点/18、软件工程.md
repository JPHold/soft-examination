[TOC]
# 开发模型
| 模型     | 是否面向对象     | 描述 |
| -------- | ---------------- | ---- |
| 瀑布模型 | 否（结构化模型） |      |
| 原型     | 否（结构化模型） |      |
| 演化模型 | 否（结构化模型） |      |
| 增量模型 | 否（结构化模型） |      |
| 螺旋模型 | 否（结构化模型） |      |
| V模型    | 否（结构化模型） |      |
| 喷泉模型 | 是               |      |
|          |                  |      |

## 瀑布模型
1970年提出，现已被淘汰了，有缺陷：**项目会延期、成本超出、甚至失败**
属于结构化方法的模型

* **原因：**
1. 做完后，用户又说跟当时的想法不一样，又重新需求分析，成本很高
2. 无法灵活应对需求的变化

* **适合场景**
4. 不适合前期阶段的需求不明确

2. 适合需求明确、二次开发


![[Pasted image 20220423170153.png]]

## 原型
* **原型是瀑布模型的互补**

* **非代码或简单的系统（只涉及到前台，不涉及到后台）**

* **如何应对用户不知道要做什么**
做出简易系统（比如一套可互动的原型界面：比如墨刀；也可以开发一个初步系统）。
用户想象不出来、不知道想要什么，你就先给出初步东西，演示一遍，用户才能提出什么想法

* **适用场景**
只在需求分析阶段使用

![[Pasted image 20220423171854.png]]

## 增量模型
* **增量模型是先做核心功能，逐个进行**
* 每次增量，都是一个完整的流程（原型+瀑布模型），然后发一个版本，集成到系统中，给用户使用

![[Pasted image 20220423173949.png]]

## 螺旋模型
* **多个模型组成：原型、演化模型、瀑布模型**
* **引入了风险分析**

![[Pasted image 20220423174000.png]]

## V模型
> 对测试进行细分和看重；在前面步骤都考虑测试如何进行，避免最终效果与需求不符，及时发现，节省成本

* **需求分析阶段**
编写系统测试和验收测试如何进行，确保最终效果与需求匹配

* **概要设计**
模块是划分的（比如由多个人独立开发），所以要测试模块的衔接

* **详细设计**
要求单元测试贯穿整个开发阶段

![[Pasted image 20220423181937.png]]

## 喷泉模型
面向对象

![[Pasted image 20220423181937.png]]

## RAD
* **快速开发模型**

* **结合瀑布模型和构建化开发模型CBSD

VB、delphi可视化开发，那就是RAD，快速开发组件

![[Pasted image 20220423181937.png]]

## 构件组装模型(CBSD)
* **标准构建**
* **极大提高软件开发的复用性**
* **减少开发时长、成本**
* **提高软件稳定性**
构件库，已经经历过多次验证，不会出错
* 构建标准
COM、DCOM、COM+是微软
EJB是java下的组件

## 统一过程
[[重点]]选择题、案例分析、分析协作

![[Pasted image 20220424214832.png]]

* **简称up（也叫RUP）**

* **适用场景**
大型项目


* **三大核心**
1. 用例
是指导测试用例的开发依据，开发过程中负责串连。

2. 架构中心
搭个架子，之后再填充细节

3. 迭代与增量
经过一个个完整流程，直到交付

* **初始**
二八定义，80%时间使用到20%功能


**细化**
主要完成架构设计

* **交付**
α测试和β测试都是针对产品，由用户发起的测试
α测试：开发阶段的内部测试版本，比如你下载alpha版的QQ
β测试：公开的测试版本，比如你下载beta版的QQ


## 敏捷开发方法
[[重点]]目前公司，用的比较多，虽然是中型项目

* 前面重量级的模型，需要形成大量文档、设计等，开发人员的负担很重。目的是减轻
* **最重要的是人力资源，将没必要的会议去掉（比如传达某些意见）**
* 适合小型项目
* 极限编程：sp方法
* **计划游戏**
让用户参与进来，并不是墨守成规的文档，而是使用比喻，跟用户描述问题

* **结对编程**
一人编码、另一人在旁观看；遇到问题时，可以集思广益，快速解决

![[Pasted image 20220424221457.png]]

## 信息系统开发方法
* 结构化
* 原型
* 面向对象
用的更多，取代结构化方法（不够灵活，系统与现实有差距）。
抽象、封装、多态。使用人类思维，抽象看待问题
比如spring

* 面向服务
跟SOA面向服务架构


![[Pasted image 20220424223650.png]]

## 需求工程
### 分类

#### 业务需求
宏观、全局角度，大的想法。比如开发什么样的系统

#### 用户需求
找各个角色获取需求，微观角度

#### 系统需求
可计算化的，指定如何开发
比如界面设计

* **细分如下**
1. 功能需求
2. 性能需求
3. 设计约束
比如选择语言、架构等，与前两者无关



### QFD(质量感叹模型)
#### 基本需求
用户明确要求，清楚要什么东西

#### 期望需求
用户不明确要，但用户觉得无需讲，觉得你们领会到他们的意思，并会做出来

#### 兴奋需求
用户没明确要，也没觉得必须做；但你们做出来了，是亮点
不提倡，并严格控制（无关紧要，分析哪些该做、必须做，哪些不该做）；
属于额外的事情，涉及到成本问题

![[Pasted image 20220425215240.png]]

## 结构化设计
![[Pasted image 20220425215708.png]]

* **概要设计和详细设计**

1. 自顶向下，逐步求精
一步步拆分，细化

2. 信息隐蔽
内部信息不向外部展现，只通过接口出去

3. 模块独立
修改某个模块，需考虑影响范围，假如是紧耦合，那么修改后，要进行回归测试（所有涉及到该模板的模板都要重新测试一遍，成本高）
* **所以要高内聚、低耦合、降低复杂度**


-------

1. 扇入
其它模板使用当前模板

多扇入
模板要多被复用

2. 扇出
当前模板使用其它模板

少扇出
当前模块，少依赖其他模块

-----
![[Pasted image 20220425215745.png]]

1. 内聚
内聚程度是功能内聚最高，偶然内聚最低

2. 耦合
耦合程度是内容耦合最高，非直接耦合最低


------
系统结构/模块结构
![[Pasted image 20220425215810.png]]

1. 变换型系统结构
感觉像是简单方式，1入参无返参、无入参+返参、1入参+返参

2. 事务型系统结构
感觉像是根据入参，走不同的代码分支

3. 混合型系统结构
混合前面两种结构


# 测试

## 测试原则与类型
* **回归测试**
修复bug后，不止是测试当前bug是否修复，之前测过没问题的流程，也要测试，也就是完整测试。因为修复了bug，可能引入新的bug

* 尚未发现的错误数量与该程序已发现错误数成正比
因为修复bug后，可能引入新bug，因此是同比增长的

* **动态测试**
使用计算机测试

* **静态测试**
手动测试
桌前检查：写完代码后，重新阅读一遍
代码走查：人工执行一遍，携带参数执行，应该是单元测试
代码审查：互相检查（review）

![[Pasted image 20220425222329.png]]

## 测试用例设计
| 分类     | 描述                                                         | 判定测试成功             | 缺点                                                   | 优点 |
| -------- | ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------ | ---- |
| 黑盒测试 | 只知道什么功能、需要什么入参、输出什么结果                   | 通过入参，输出怎样的结果 | 测试覆盖度不高，不知道代码内部有几种可能，无法测试完全 |      |
| 白盒测试 | 知道内部结构：比如知道有多少个分支代码；测试时所有分支都测试 | 所有可能都测试通过，覆盖度达到最大                         | 耗时比较长                                                       |      |

![[Pasted image 20220425225823.png]]

### 黑盒测试
通过科学合理的方法，也能提高测试的覆盖度

* **等价类划分**
把所有数据类归总划分，分别划分为同一类，在同一类中选择一个数据来测试。测试样例就可以覆盖全面。
比如成绩的优良中差：各个选一个分数进行测试

* **边界值分析**
处于两种等价类之间的数据，假设优是>90，良是>70，得知是90是边界值，经过测试却为量，测试失败

* **错误推测**
经验所得，哪些地方容易出错

* **因果图**
通过结果，反推入参

### 白盒测试
* **基本路径测试**
1. 语句覆盖
最低层次的测试，只要所有语句测试过就行，不考虑分支的组合

2. 判定覆盖
覆盖所有分支的组合

3. 条件覆盖
拆开判定语句，每个判断条件都作为一个独立用例，详细测试

**2022年4月25日 23:02:53 我的测试方法应该是路径覆盖，比其他同事耗费更长时间**

* **循环覆盖测试**


* **逻辑覆盖测试**


## 测试阶段
![[Pasted image 20220425233932.png]]

确认测试和系统测试的顺序，在不同的书籍讲解中，是不相同的。
* **冒烟测试**
最初步尝试的一次检测，先看看哪里会有问题，跟回归测试的完整度是不一样的

* **单元测试**
针对模块的局部测试，局部包括：接口、函数等

* **集成测试**
先模块的组装，再进行衔接测试

**组装**
1. 一次性组装
速度快，但可能测试不来问题

2. 增量式组装
逐次增加模块进来参与测试，速度慢，但测试问题全面

**只有一个模板也可以集成测试**
模拟上级模板的入参和下级模块的返参：驱动模板和桩模块配合测试
类似于mock测试

* **确认测试**
包含验收测试，所以一般放在最后；
只有软件，那么测试到此为止
1. 内部确认测试
2. Alpha测试
3. Beta测试
4. 验收测试

* **系统测试**
包含软件和硬件：开发完软件，要结合硬件进行测试
[[坑]]没讲明白

**主要是压力测试、性能测试**

**性能测试**
1. 负载测试
不同并发下，响应qps

2. 强度测试
资源下降，能不能抗住

3. 容量测试

**压力测试**
极限值的测试，比如只能容纳1000人访问，这时使用1万人去测试

## McCache复杂度环路复杂度
[[重点]]

![[Pasted image 20220426201720.png]]

* **计算公式：（有向边数量-节点数量）+2**

* **涉及到分叉但无节点，需不需要抽象为节点。**
抽象与否，环路复杂度都是一样的，所以都可以

# 系统运行与维护
![[Pasted image 20220426202555.png]]

* **维护的标准**
1. 易分析性
容易看懂：变量、结构的规范性，可阅读星

2. 易修改性
设计中的低耦合

3. 稳定性

4. 易测试性
方便回归测试

* **维护类型**
1. **改正性维护（正确性维护）**

测试阶段，无法找出所有bug，有些会在用户使用阶段发现

2. **适应性维护**
适应相应的操作环境，比如升级到linux8、window2013
适应相应的数据环境
适应需求变化（可能是为了适应甲方或乙方的发展，比如前瞻性、垄断）

3. **完善性维护**
扩充功能、提升性能

4. **预防性维护**
闲置时间时，对功能重构、文档编写等

# 软件过程改进-CMMI
* **由CMM发展而来，软件能力成熟度模型**
* **衡量软件承包商改善软件的能力**

![[Pasted image 20220426204721.png]]

* 阶段式和连续式的区别
1. 阶段式在招标有帮助，分级管理，就知道达到哪个级别，能满足甲方的要求

* **问题**
1. 国内大部分公司，都是为了拿CMMI证，能力并没有跟上

### 阶段式
2022年4月26日 20:50:23 现在公司是处于已管理和已定义级的之间，并且要达到已定义级还要一段时间

1. 混乱
没达到CMMI

2.已管理级
项目级，仅仅当事人，有相应实施的经验。换个人就不一定能成功实施或实施困难。经验没有共享到公司层面，只是个人层面

3. 已定义级
组织级，标准模板等标准化东西，落实到每个项目，集成化
知识分显性和隐性，这里将隐形转为显性

4. 定量管理级别
管理量化

5. 优化


### 连续式

# 项目管理
分值低，不重要[[重点]]

**主要考**
* 时间管理
gan'te'tu

* 风险管理