9[TOC]

# 数据结构
![[Pasted image 20220407213257.png]]
 > 图有环路，从部分来看，包含线性结构和树
 > 树，假如只有一个子节点，那么也是线性结构

# 数组与矩阵

## 数组
### 计算某个位置的存储地址
> 数组a，则开始存储地址为a
> 记每个元素所占字节为len

* **一维数组：`a[i]`**
**公式：**`a + i * len` 

* **二维数组：`a[m][n]`**
> 按存储方式不同，计算公式不同

**按行存储：**
公式：`a + (i * n + j) * len `

**按列存储：**
公式：`a + (j * m + i) * len`

**解释一下：**
* **按行存储，从左到右摆满后，再切换到下一行，继续从左到右**
所以得出当前位置是第几个，就需要数一行有多少个（**也就是多少列，即看n**）

* **按列存储，从上到下摆满后，再切换到下一列，继续从上到下**
> 所以得出当前位置是第几个，就需要数有多少行（**即看m**），是相反计算

* **下标从0开始，所以直接乘以个数即可     **

## 矩阵
### 稀疏矩阵
> 元素为0代表无效数据或重复数据

![[Pasted image 20220407212625.png]]
* **作用**
> 是否可以只用到一部分矩阵，就将有效数据存进去
> 比如图片，有重复部分，那么只要存储有效数据即可，剩下

* **考察矩阵的某个位置，换算到一维数组中，是哪个位置**
> 无须记上面那张图的公式，可以直接使用代入法
![[Pasted image 20220407212850.png]]


# 线性表
### 顺序表
* **连续空间**

### 链表
* **离散空间，使用指针相连**
> 考察删除、添加节点，指针的指定

#### 单链表
> 有无头节点，是不一样
> 头节点不存在任何数据，是为了保持一致的处理

#### 循环链表


#### 双向链表

### 顺序表与链表的对比
**需理解算法复杂度**[[不懂]]
[# 什么是算法复杂度](https://blog.csdn.net/icolakele/article/details/100167755?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&utm_relevant_index=1)
> 复杂度，是基于操作中，影响最大的执行部分：比如f(x) = 3x^3 + 2x + 10，当x越大，f(x)和3x^3，就趋近于相等，所以复杂度O(f(x))是等于O(3x^3)

| 性能类别 | 指标     | 顺序存储                         | 链式存储                             |
| -------- | -------- | -------------------------------- | ------------------------------------ |
| 空间性能 | 存储密度 | =1，更忧                         | <1                                   |
|          | 容量分配 | 事先确定                         | 动态分配                             |
| 时间性能 | 查找运算 | O(n/2)                           | O(n/2)                               |
|          | 读运算   | O(1)，更忧                       | O([n+1]/2)，最好情况为1，最坏情况为n |
|          | 插入运算 | O(n/2)，最好情况为1，最坏情况为n | O(1)，更优                           |
|          | 删除运算 | O([n-1]/2)                       | O(1)，更优                           |

## 栈和队列
* **循环队列**
> tail为当前位置（尾指针），head为开头位置
> 如果全部都占满，那么最后一个元素，他的tail指向0（也就是head），那么就无法区分是队空还是队満
> 因此公式如下：
1. 队空：`tail == head`
2. 队満：`(tail+1) % size == head`

![[Pasted image 20220409111357.png]]
> 依次进入即可解答

**答案：D**

# 广义表
> [[#线性表]]的推广
> 记作LS=(a0, a1, ..., an)，an可以是数据元素，也可以是子表，每个子表又可以包含数据元素或子表，如此嵌套下去。
> [[重点]]，考察长度和深度，而长度是最外层的元素个数，深度是嵌套的深度

![[Pasted image 20220409113011.png]]

**例2的答案：head(head(tail(LS1)))**

# 树与二叉树
## 属性概念
| 属性     | 描述                                           |
| -------- | ---------------------------------------------- |
| 结点的度 | 某个结点有多少个子结点                         |
| 树的度   | 基于结点的度，取最大数                         |
| 叶子结点 | 没有子结点的结点                               |
| 分支结点 | 有子结点的结点                                 |
| 内部结点 | 上有父节点，下有子结点的节点（夹在中间的结点） |
| 父结点   | 有子结点的结点                                 |
| 子结点   | 有父结点的结点                                 |
| 兄弟结点 | 同级结点                                       |
| 层次     | 高度                                           |
![[数据结构与算法基础-属性概念]]

## 二叉树的种类
| 类型         | 描述 |
| ------------ | ---- |
| 満二叉树     |      |
| 完全二叉树   |      |
| 非安全二叉树 |      |
|              |      |

# 图

# 排序与查找
* **时间复杂度**
* **空间复杂度**

# 算法基础及常见的算法
