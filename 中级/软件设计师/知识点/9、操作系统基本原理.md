    [TOC]

# 概述
![[Pasted image 20220212161609.png]]

* 作用
1. 管理系统的硬件、软件、数据资源
2. 控制程序运行
3. 人机之间的接口
4. 应用软件与硬件之间的接口

* 包含以下管理
1. 进程管理
2. 存储管理
3. 文件管理
4. 作业管理
5. 设备管理

# 进程管理

## 进程的状态
> 为进程赋予状态，是为了方便管理

![[绘图/操作系统基本原理-进程管理-进程状态演变和流程.md]]

1. 等待事件=缺资源
2. 等待不能回到运行状态，需到就绪状态，排队等待cpu调度
3. cpu执行任务，采用时间片轮转，限制了执行时间，即使该任务还没执行完成，也会被暂停
4. **由三态模型演变成五态模型，是因为不足以满足场景，比如挂起**

## 前驱图
>描述的是哪些步骤可并行执行，哪些步骤有先后约束关系

![[绘图/操作系统基本原理-进程管理-前驱图.md]]

## 进程的同步与互斥
> 互斥，同一时刻，只能进行一个任务，任务之间无关联，所以可以乱序执行
> 同步，同一时刻可以执行多个任务，但任务A需要依赖任务B的数据才能继续执行，等待完毕后，一起结束整体任务

## PV操作
* 临界资源
> 每个进程，需要以互斥方式来访问的资源，称为临界资源

* 临界区
> 每个进程中访问临界资源的那段代码，称为临界区

* 信号量
> 特殊变量

-----

PV流程图[[不懂]]
![[绘图/操作系统基本原理-进程管理-PV操作.md]]

> 大概流程：V代表发送消息，P代表接收消息并处理


* **例子**

某书店有一个收银员,该书店最多允许n个购书者进入。将收银员和购书者看作不同的进程，其工作流程如下图所示。利用PV操作实现该过程，设置信号量S1、S2和Sn，初值分别为0、0、n。则图中al和a2应填入(1)，图中bl和b2应填入(2)。

![[Pasted image 20220305110422.png]]
(1) A.  V(S1)、P(S2)， B.  V(Sn)、P(Sn) ，C.  P(S1)、V(S2)，D.  P(S2)、V(S1) 
(2) A.  P(Sn)、V(S2)，B.  V(Sn)、P(S2) ，C.  P(S1)、V(S2)，D.  P(S2)、V(S1)

**答案：A、C**

### PV操作与前驱图
- 根据[[#前驱图]]，转换成相应的进程，进行PV操作
![[Pasted image 20220305111819.png]]

* **例子**
进程P1、P2、P3、P4、P5的前趋图如下图所示。若用PV操作控制进程并发执行的过程，则需要设置4个信号量S1、S2、S3和S4,且信号量初值都等于零。图中a和b应分别填写(1)，c和d应分别填写(2)，e和f应分别填写(3)
(1) A.  P(S1)和P(S2)          B.  P(S1)和V(S2)
     C.  V(S1)和V(S2)          D.  V(S1)和P(S2)
(2) A.  P(S1)、P(S2)和V(S3)、V(S4)          B.  P(S1)、P(S2)和P(S3)、P(S4)
      C.  V(S1)、V(S2)和P(S3)、 P(S4)         D.  V(S1)、V(S2)和V(S3)、V(S4)
(3) A.  P(S3)和P(S4)          B.  P(S3)和V(S4)
      C.  V(S3)和V(S4)          D.  V(S3)和P(S4)

**答案：C、A、A**
![[Pasted image 20220305112726.png]]

## 死锁问题
### 死锁的原因
> 如果一个进程在等待一个不可能的事，则进程就死锁，多个进程死锁，进而导致系统死锁

**不可能的事有如下原因：** ^f70d62
1. 互斥（进程之间互斥执行，资源不共享）
2. 保持和等待（自己资源不给别人，别人资源也不给我）
3. 不剥夺（系统不会剥夺进程资源给其它进程）
4. 环路等待（进程A需要进程B的资源、B进程需要C进程的资源、C进程需要A进程的资源）

* **最低多少个资源才不会导致死锁**

> 比如k个进程，一个进程需要n个资源才能完成执行，那么至少需要`k * (n-1) + 1` 个资源才不会死锁

* **预防死锁，需要打破这四个条件**[[#^f70d62]]

* **避免死锁的两种方式**
1. 有序资源分配法（只能按顺序执行，效率低）
2. 银行家算法[[#银行家算法]]（选择出最优解，效率高）

### 银行家算法
* **基于资源分配的原则**

1. 当一个进程申请的所需最大需求资源数，不超过系统的总资源数，允许该进程的申请
2. 可允许进程分期请求资源，但总数不能超过最大需求资源数
3. 当系统现有资源无法满足该进程，可延迟分配，但总能在有限时间得到资源

* **怎样的分配顺序，才能保证不死锁**
1. 题目
![[Pasted image 20220308225514.png]]

2. 解题过程，
![[Pasted image 20220308225523.png]]

![[Pasted image 20220308225530.png]]

# 存储管理
### 分区存储组织
> 给任务分配内存空间，有以下四种分配方式

1. 首次适应法
> 按区顺序分配

2. 最佳适应法
> 按区的剩余空间，从小到大，进行分配
> 会小空间的区被占用后，剩下的空间过于小，导致无法再分配

3. 最差适应法
> 按区的剩余空间，从大到小，进行分配 

4. 循环首次适应法
> 从上次分配的区开始，如果当前区可以满足当前任务，则在该区进行分配，否则下个区

**看图**     
![[绘图/操作系统基本原理-存储管理-分区存储组织.md]]

### 程序的存储方式
> 以前的程序加载到内存中，是分配整块地址空间，但如果程序过大，并不能一次性装入
，因此出现分片段存储，需要哪段程序，才调用到内存中执行

#### 优缺点
| 方式           | 优点                                                                                        | 缺点                                                                             | 考察点                 |
| -------------- |:------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- | ---------------------- |
| 页式存储组织   | 1.利用率高，碎片少（比如4k为一块或一页，有个2k程序段，那只会浪费2k大小）  2. 分配及管理简单 | 1. 增加了系统开销（因为要将程序段调入到内存中执行，需要先查询页表）  2. 产生抖动 | 根据逻辑地址，物理地址 |
| 段式存储组织   | 1.多道程序共享内存  2.各段程序修改互不影响                                                  | 1.内存利用率低，内存碎片浪费大                                                   |                        |
| 页段式存储组织 | 1. 空间浪费小  2. 存储共享容易  3、存储保护容易  4. 动态链接                                | 1. 复杂性和开销增加  2. 需要的硬件以及占用内容也有所增加，使得执行速度大大下降   |                        |                                                        |                                                                                  |                        |


#### 慢表
> 存放在内存中

##### 页式存储组织
> 比如按4k大小，将程序划分成一个个页；将内存划分成一个个块。
> 用页表关系表，维护程序页与内存块的映射

**页号也称为页帧号**
![[操作系统基本原理-存储管理-页式存储组织]]

###### 根据逻辑地址，计算物理地址
> 首先页内地址与物理地址是一样的
> 计算原理：业内地址直接是物理地址；根据页号在页表中查询出对应的块号；这个块号拼接到物理地址上，这就是最终地址

**例子：**
>进程P有6个页面，页号分别为0~5，页面大小为4K，页面变换表如下所示。
>表中**状态位等于1和0分别表示页面在内存和不在内存**、**访问位等于1和0分别表示刚被访问过和很久之前被访问过**
>假设系统给进程P分配了4个存储块，进程P要访问的逻辑地址为十六进制5A29H，那么该地址经过变换后，其物理地址应为十六进制 (1) ；如果进程P要访问的页面4不在内存，那么应该淘汰页号为 (2) 的页面。

| 页号 | 页帧号（块号） | 状态位 | 访问位 | 修改位 |
| ---- | -------------- | ------ | ------ | ------ |
| 0    | 2              | 1      | 1      | 0      |
| 1    | 3              | 1      | 0      | 1      |
| 2    | 5              | 1      | 1      | 0      |
| 3    | -              | 0      | 0      | 0      |
| 4    | -              | 0      | 0      | 0      |
| 5    | 6              | 1      | 1      | 1      |

（1）A. 1A29H    B. 3A29H    C. 5A29H    D. 6A29H
（2）A. 0    B. 1    C. 2    D. 5

**解题思路：**
* 第一个问题：先将4K换算为二进制：`4*1024`=4096=2^12，因为四个位等于一个十六进制数，因此占据三个数，则A29为页内地址；5为页号，查询页表，得知块号为6，则最终答案为`6A29H`
* 第二个问题：既然四个存储块都有程序段，则需要踢出一个，状态位为1是在内存中，因此从0、1、2、5决择；再基于访问位：为0代表很久之前被访问过，则可以提出；则最终答案为`1`

##### 段式存储组织
> 长度可长可短，便于共享
![[操作系统基本原理-存储管理-段式存储组织]]


##### 段页式存储
> 是段式和页式的折中，先分段，再分页

![[操作系统基本原理-存储管理-段页式存储组织]]


#### 快表
> 小容量的相联存储器，由高速缓存器组成。速度快，并且可以从硬件上保证按内容进行查找，一般用来存放当前访问最频繁的少数活动页面的页号


### 页面置换（页面淘汰）算法
> 用在分层存储体系
> cache满了之后，新的块要进来，就需要页面置换
> 内存的页占满之后，需要踢掉一些页，也需要页面置换

| 算法类别     | 描述                                                                           | 优点                                           | 缺点   | 场景                 |
| ------------ | ------------------------------------------------------------------------------ | ---------------------------------------------- | ------ | -------------------- |
| 最优算法     | 比对所有页面，剔除哪个，释放的性能最佳（但操作起来很麻烦，逻辑和顺序无法获知） |                                                |        | 给其它三个算法做参考 |
| 随机算法     |                                                                                |                                                |        |                      |
| 先进先出     |                                                                                |                                                | 会抖动 |                      |
| 最近最少使用 |                                                                                | 不会抖动，最近运行的，不会被置换（局部性原理） |        |                      | 

#### 抖动
[[重点]]
> 某个程序需要占用3个页，无法执行的概率（或叫缺页率）是10%。为了保证能执行，多分配一个页给它，但却导致缺页率提升到14%
> 引入越多页，反而导致被置换的概率提升

##### 缺页
> **程序页是否已存在于内存页**


##### 缺页率的增加
> 视频中列举了个例子，描述的是增加一个内存页，缺页率增加，但自己使用内存页个数和程序页个数一样的情况下，缺页率是降低的[[坑]]

> 判断是否缺页：[[#缺页]]


* **3个内存页+5个程序页**

缺页：9

|      | 4   | 3   | 2   | 1   | 4   | 3   | 5   | 4   | 3   | 2   | 1   | 5   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1    | 4   | 4   | 4   | 3   | 2   | 1   | 4   | 4   | 4   | 3   | 5   | 5   |
| 2    |     | 3   | 3   | 2   | 1   | 4   | 3   | 3   | 3   | 5   | 2   | 2   |
| 3    |     |     | 2   | 1   | 4   | 3   | 5   | 5   | 5   | 2   | 1   | 1   |
| 缺页 | ✔   | ✔   | ✔   | ✔   | ✔   | ✔   | ✔   |     |     | ✔   | ✔   |     |

* **4个内存页+5个程序页**

缺页：10

|      | 4   | 3   | 2   | 1   | 4   | 3   | 5   | 4   | 3   | 2   | 1   | 5   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1    | 4   | 4   | 4   | 4   | 4   | 4   | 3   | 2   | 1   | 5   | 4   | 3   |
| 2    |     | 3   | 3   | 3   | 3   | 3   | 2   | 1   | 5   | 4   | 3   | 2   |
| 3    |     |     | 2   | 2   | 2   | 2   | 1   | 5   | 4   | 3   | 2   | 1   |
| 4    |     |     |     | 1   | 1   | 1   | 5   | 4   | 3   | 2   | 1   | 5   |
| 缺页 | ✔   | ✔   | ✔   | ✔   |     |     | ✔   | ✔   | ✔   | ✔   | ✔   | ✔   |


* **5个内存页+5个程序页**

缺页：5

|      | 4   | 3   | 2   | 1   | 4   | 3   | 5   | 4   | 3   | 2   | 1   | 5   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1    | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   | 4   |
| 2    |     | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 3   | 3   |
| 3    |     |     | 2   | 2   | 2   | 2   | 2   | 2   | 2   | 2   | 2   | 2   |
| 4    |     |     |     | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| 5    |     |     |     |     |     |     | 5   | 5   | 5   | 5   | 5   | 5   |
| 缺页 | ✔   | ✔   | ✔   | ✔   |     |     | ✔   |     |     |     |     |     |

#### 算法比较
##### 先进先出 vs 最近最少使用
在一个虚存系统中，进程的内存空间为3页，开始内存为空，有以下访问页序列: 50120304230321201501，分别计算缺页次数。
(1) 使用先进先出的页面淘汰算法。
(2) 使用最佳适应算法。
(3) 使用最近最少使用算法。8960[]

**解答**
> 访问第二个0程序页，FIFO和LRU是不同的
> FIFO是淘汰第一个0，因为最先进来的是它
> LRU是淘汰1，因为当前访问是0页，因此基于最近最少使用，其实是1

|      | 5   | 0   | 1   | 2   | 0   | 3   | 0   | 4   | 2   | 3   | 0   | 3   | 2   | 1   | 2   | 0   | 1   | 5   | 0   | 1   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| FIFO | ✔   | ✔   | ✔   | ✔   |     | ✔   | ✔   | ✔   | ✔   | ✔   | ✔   |     |     | ✔   | ✔   |     |     | ✔   | ✔   | ✔   |
| 淘汰 |     |     |     | 5   |     | 0   | 1   | 2   | 3   | 0   | 4   |     |     | 2   | 3   |     |     | 0   | 1   | 2   |
|      |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| LRU  | ✔   | ✔   | ✔   | ✔   |     | ✔   |     | ✔   | ✔   | ✔   | ✔   |     |     | ✔   |     | ✔   |     | ✔   |     |     |
| 淘汰 |     |     |     | 5   |     | 1   |     | 2   | 3   | 0   | 4   |     |     | 0   |     | 3   |     | 2   |     |     |

#### 练习题
在一台按字节编址的8位计算机系统中，采用虚拟页式存储管理方案，页面的大小为1KB，且系统中没有使用快表(或联想存储器)。图所示的是划分成6个页面的用户程序。
![[Pasted image 20220321211101.png]]
图中swap A, B是16位的指令，A和B表示该指令的两个16位操作数。swap指令存放在内存的1023单元中，操作数A存放在内存的3071单元中，操作数B存放在内存的5119单元中。执行swap指令需要访问 (1) 次内存,将产生 (2) 次缺页中断。
(1) A. 6   B. 12   C. 18   D. 24
(2) A. 3  B. 4   C  5   D. 6

**解题**
> 基于以下两个规则：
1. 因为没使用快页，所以需要访问页表，然后再访问内存块。**一次程序页的访问，需要访问两次内存**
2. 因为命令只有一次缺页中断，其它是两个缺页中断

* 总共是6个页面，所以`6 * 2 = 12次访问`，选B
* 一个命令，两个操作数，所以`1 + 2 + 2 = 5`，选C

# 文件管理
 ## 索引文件结构
 | 名称             | 描述                                                                                               |
 | ---------------- | -------------------------------------------------------------------------------------------------- |
 | 直接地址索引     | 逻辑块直接指向物理块                                                                               |
 | 一级间接地址索引 | 逻辑块指向一级逻辑块，一级逻辑块直接指向物理块                                                     |
 | 二级间接地址索引 | 逻辑块指向二级逻辑块，二级逻辑块指向一级逻辑块，一级逻辑块直接指向物理块                           |
 | 三级间接地址索引 | 逻辑块指向三级逻辑块，三级逻辑块指向二级逻辑块，二级逻辑块指向一级逻辑块，一级逻辑块直接指向物理块 |
 | ...间接地址索引  | 同理                                                                                               |

![[操作系统基本原理-文件管理-索引文件结构]]

### 练习题
> 假设文件系统采用索引节点管理，且索引节点有8个地址项iaddr[0]~iaddr[7]，每个地址项大小为4字节，iaddr[0]~iaddr[4]采用直接地址索引，iaddr[5]和iaddr[6]采用一级间接地址索引，iaddr[7]采用二级间接地址索引，假设磁盘索引块和磁盘数据块大小均为1KB字节，文件File1的索引节点如下图所示，若用户访问文件File1中逻辑块号为5和261的信息，
> 则对应的物理块分别为（1），101号物理块存放的是（2）。

![[操作系统基本原理-文件管理-索引文件结构-练习题]]

（1） A. 89和90   B. 89和136
          C. 58和187  D. 90和136
（2）A. File1的信息
         B. 直接地址索引表
         C. 一级地址索引表
         D. 二级地址索引表

* **解题**
**第一个问题**
1. 因为iaddr[0]~iaddr[4]对应是0~4物理块，接下来是iaddr[5]，因此58逻辑块对应的是第5个物理块，答案：**58**
2. 需要得知逻辑块总共有多少个地址，已知逻辑块是1KB字节大小，一个地址项大小是4字节：`(1 * 1024) / 4  = 256`，因为第5个物理块占据了一个地址，因此只需加上255（256-1），iaddr[5]对应的一级间接索引的最后一块是255，那么iaddr[6]对应的一级间接索引的第一块是251，对应的逻辑块是187，答案：**187**

**第二个问题**
1. 有两个索引结构，因此答案：二级地址索引表

## 文件和树型目录结构
### 文件属性
1. R（只读文件属性）
2. A（存档属性）
3. S（系统文件）
4. H（隐藏文件）

### 文件名的组成
1. 驱动器号
2. 路径
3. 主文件名
4. 扩展名

### 相对路径和绝对路径
绝对路径是完整路径，从根目录到你当前位置
相对路径是相对某个目录下       


##  空闲存储空间的管理
### 空闲区表法（空闲文件目录）
### 空闲链表法
### 位示图法
### 成组链接法

---------
考察的是位示图法，1代表占据，0为空闲

> 某文件管理系统在磁盘上建立了位示图(bitmap)，记录磁盘的使用情况。若磁盘上的物理块依次编号为:0、1、2、…，系统中字长为32位,每一位对应文件存储器上的一个物理块，取值0和1分别表示空闲和占用，如下图所示。

![[Pasted image 20220323225441.png]]
假设将4195号物理块分配给某文件，那么该物理块的使用情况在位示图中的第 (1) 个字中描述；系统应该将 (2)
(1) A . 129  B . 130   C. 131   D. 132
(2) A.该字的第3位置“0”
	B.该字的第3位置“1”
	C.该字的第4位置“0”
	D.该字的第4位置“1”

**解题**
1. 因为4195是第4195块，从0开始，所有总块数是4196，因此计算出总共字：`4196/32 = 131.125`，向上取整：132。答案：132
2. 因为从131开始数会比较简单：计算对应块数：`131*32=4192,`，也就是第4191块，那么从4192是第0个位置、第1个位置-》4193、第2个位置-》4194、第3个位置-》4195。答案：3

# 设备管理
## 数据传输控制方式

| 方式                     | 描述                                        |
| ------------------------ | ------------------------------------------- |
| 程序控制方式（查询方式） | 内存要不断去询问是否完成，外设不够主动      |
| 程序中断方式             | 外设完成之后，发出中断指令，内存就收到通知  |
| DMA（直接存储控制方式）  | 控制器完成把控，cpu只需在开头做一些任务定义 |
| 通道                     | 少考                                        |
| 输入输出处理机           | 少考                                        |

### 通道
![[Pasted image 20220324220321.png]]


## 虚设备与SPOOLING技术
* **打印机场景**
假设没有这个技术，你每次打印时，都可能提示被占用
有这个技术后，**多了缓冲区**，先存到硬盘的缓冲区；打完一个任务，再打下一个

![[Pasted image 20220324220521.png]]


# 微内核操作系统
* 为何要把微内核做小
1. 可靠性
2. 稳定性
3. 安全性
> 操作系统是电脑最核心的部分，如果出故障，直接影响使用。因此做小，核心功能放内核中，其它功能抽出去，作为外接系统（文件系统、图形系统、设备驱动等），哪个出问题就重启哪个

**下面列举单体系统和微内核的比对**
|          | 实质 | 优点 | 缺点 |
| -------- | ---- | ---- | ---- |
| 单体内核 |将图形、设备驱动及文件系统等功能全部在内核中实现,运行在内核状态和同一地址空间。      | 减少进程间通信和状态切换的系统开销,获得较高的运行效率。     |内核庞大,占用资源较多且不易剪裁。系统的稳定性和安全性不好。      |
| 微内核         |      |      |      |

操作系统基本原理
微内核操作系统
进程
终端
文件
存储器
客户进程|客户进程|服务器|服务器
||服务器|服务器
请求
核心
回答
用户态
核心态
实质
优点
缺点
单体内核




微内核
内核精练,便于剪裁和移
只实现基本功能,将图形系统、文件系统、设系统服务程序运行在用户找从而需要
植。


内核之外。
稳定性和安全性较高。
可用于分布式系统
www.educity.cn-帮助客户成功,创造社会价值

* 微内核还分核心态和用户态
