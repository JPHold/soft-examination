[TOC]

# 进制换算
1. x进制转十进制
	使用按权展开法，
	小数点左侧的正数部分：以x为底，每个位所在位置（从0开始）为幂，形成指数
	小数点右侧的负数部分：以x为底，每个位所在位置（从-1开始）为幂，形成指数
	![[Pasted image 20211118135730.png]]
	再将指数乘以对应位上的数
	
	**例子：**
	二进制1000 0001=![[Pasted image 20211118135258.png]]
	二进制1000 0001.0001=![[Pasted image 20211118140035.png]]
	
2. 十进制转x进制
	使用短除法，
	x作为被除数，商作为下次的除数，余数作为位数
	
	**例子：**
	![[Pasted image 20211119182442.png]]
	从底到顶部组合成二进制：01011110

3. 二进制转x进制
	以x为底，每个位所在位置（从0开始）为幂，形成指数，再根据不同转换的进制对应的位数，相加形成一个组合数，最终将这些组合数拼接一起得出结果
	八进制是3个位形成一个组合数
	十六进制是4个位形成一个组合数，大于10按A(0)

# 底层的数运算
这里涉及到位运算：与运算、或运算、异或运算
加法采用或运算（计算机为了简化计算，因此减法的计算方式也会变成加法：x+(-y）；
乘法采用与运算；

![[Pasted image 20220210130918.png]]

| 类型 | 描述                                                                                  | 例子 |
| ---- | ------------------------------------------------------------------------------------- | ---- |
| 原码 | 表达一个数的二进制形式                                                                |      |
| 反码 | 在原码基础上，符号位不变; 正数不变，负数取反                                          |      |
| 补码 | 在反码基础，正数不变；负数，基于减法规则，再加个0000 0001，最终换算成实际的二进制位数 |      |
| 移码 | 在补码基础上，符号位取反                                                              |      |

**相加例子（1-1）；都采用或运算**

| 类型 | 数值1     | 数值-1    | 结果              |
| ---- | --------- | --------- | ----------------- |
| 原码 | 0000 0001 | 1000 0001 | 1000 0010（-2）   |
| 反码 | 0000 0001 | 1111 1110 | 1111 1111（-127） |
| 补码 | 0000 0001 | 1111 1111 | 0000 0000（0）    |
| 移码 | 1000 0001 | 0111 1111 | 1000 0000         |

一些规律：
1. 其中有个1即为1、两者为1，则进1位，当前位变0
2. 如果进1位，发现后一个位数是1+1，这时的计算是1+1+1，两两组合相加：1+1（仅为进1位），接着将进1位的1再加上1，最终结果0，进一位，**所以结论：多个1相加，结果都为0，且进1位**
4. 原码的计算逻辑依据（并不是像视频老师那么浅显的讲解[[坑]]）（**这个规则太多，换算成补码会简单很多**）：
```
加法：同号求和，异号求差
减法：异号求和，同号求差
求和：

数值位相加
符号取被加数（被减数）的符号。
最高位有进位表示溢出
求差：

被加数（被减数）加上加数（减数）的变补
最高数值位产生进位表示结果为正，所得数值位正确
最高数值位没有产生进位表示结果为负，对结果求补，还原为绝对值形式的数值位
最高数值位产生进位，符号取被加数（被减数）的符号。
最高数值位没有产生进位，符号取被加数（被减数）的符号取反。
```
5. 补码的计算逻辑根据（并不是像视频老师那么浅显的讲解[[坑]]）：
```
都转成补码；
是减法则变成加法；
得出结果，如果不是0则需转原码（0则直接采用结果）：先减1，除符号位外都取反（也就是逆操作）

```

6. 移码的计算逻辑根据（并不是像视频老师那么浅显的讲解[[坑]]）：
```
补码相加，符号位取反
```

# 数值的范围
分为定点整数和定点小数；
前者：在最低位后面带上小数点，但因为是整数，所以一般都不写
后者：小数点在符号位的后面
**小数点不占位数，不影响计算**
## 定点整数
| 类型 |
| ---- |
|      |

## 定点小数

 # 浮点数运算
 尾数、基数、指数
 指数也叫阶码
 
 运算过程：
 1. 对阶
 2. 尾数计算
 3. 结果格式化
 
 特点：
 1. **尾数用补码存储，指数（阶码）用移码存储**
 2. 尾数的位数越多，精度越高
 3. 指数越大，标识范围越大
 4. 对阶，小阶码往大阶码靠拢；同时较小的尾数向右移，阶码增加多少，就右移多少
 
 存储结构：
 
| 浮点数         | 阶符号 | 阶码（转成移码得出） | 数符号    | 尾数（转成补码得出） |
| -------------- | ------ | -------------------- | --------- | ------------------ |
| $0.1×10^3$ | 0      | 1000 0011（3）       | 0   | 0000 0001（1） |                    |

 
 例子：
 $0.1×10^3$
 $1.2×10^5$
 第一个数对阶后：$0.001×10^5$
 尾数计算：$0.001×10^5$ +  $1.2×10^5$ =  $1.201×10^5$
 