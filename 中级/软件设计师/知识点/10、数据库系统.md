[TOC]

[[重点]]
> 上午的综合分析题、下午的案例分析或论文，都会考

# 数据库模式
> 数据库其实是文件系统

## 三级模式-两级映射
| 模式     | 定义                                         |
| -------- | -------------------------------------------- |
| 内模式   | 与物理数据库交互，用什么格式存储、如何优化等 |
| 概念模式 | 用表包含数据，表之间有关联                   |
| 外模式   | 视图，灵活控制数据                           |

![[数据库系统-三级模式-两级映射]]

> 概念模式与内模式的映射：具体化出表结构，通过表结构，影响存储方式和优化方式
> 外模式与概念模式的映射：具体化出视图，通过视图，修改与表数据的映射


# ER模型
## 数据库设计过程
![[数据库系统-数据库设计过程]]

## ER模型设计
![[Pasted image 20220326151758.png]]
1. 方形代表实体
2. 圆形代表属性
3. 菱形代表联系

### 集成合并
* **集成方法**
1. 多个局部E-R图一次集成
2. 逐步集成，累加方式一次集成两个局部E-R

* **解决合并冲突**
1. 属性冲突
属性域冲突和属性取值冲突
比如性别，一个E-R模模型是0、1表示，另一个是P、F表示

2. 命名冲突
同名异义和异名同义
比如同个字段名却不同意思、不同字段名却同个意思

3. 结构冲突
同个对象在不同应用中具有不同的抽象；
同一实体在不同局部E-R图中所包含的属性个数和属性排列次序不完全相同；

比如一个E-R模型中教师是个字段，另一个却是一个实体；
两个E-R模型对教师的定义不同：有个有家庭成员字段，另一个没有

## ER模型转关系模式
* **一个实体型转换为一个关系模式**
1. 1对1联系
两个实体，为2个关系，联系可以放在这两个之间，也可以另起一个关系，所以至少两个，最大是三个

2. 1对n联系
两个实体，为2个关系，因为关系不能放在1那边，只能放在n这边，也可以另起一个关系，所以至少两个，最大是三个

3. m对n联系
三个实体，为3个关系，关系只能另起，所以为4个

* **三个以上实体间的一个多元联系**

> 在数据库逻辑结构的设计中，将E-R模型转换为关系模型应遵循相关原则。对于三个不同实体集和它们之间的多对多联系m: n: p，最少可转换为___个关系模式。
![[Pasted image 20220327200935.png]]
A. 2    B. 3    C. 4    D. 5

**解题**
A、B、C各一个，中间的联系，所以答案：4个

# 关系代数与元组演算
[重点]选择题
![[数据库系统-关系代数]]


## 并集
相同的数据，只保留一个，然后合并在一起

## 交集
只保留相同的数据

## 差集
以某个数据集为准，他有的，而其它数据集没有的数据

## 笛卡尔积
数据集S1的每条数据，都要跟数据集S2的所有数据进行组合
**与投影有关联，因为相同字段，只会保留一个，所以得注意序号**

## 投影
> 选列，选择想要的列


## 选择
> 选行，选择想要的某行数据

## 联接
**与投影有关联，因为相同字段，只会保留一个，所以得注意序号**
* **两张表进行连接，如果不指定连接条件，默认是将同个名字的字段进行关联**
比如表a和表b，同个名字的字段有c1、c2
`select * from a,b`等同于`select * from a as a,b as b where a.c1=b.c1 and a.c2=b.c2`


# 规范化理论
## 函数依赖
> 又称为函数确定，某个属性决定另一个属性

### 部分函数依赖
> A和B共同决定C
> 比如学号、课程号，通过学号就能确定某个学生

### 传递函数依赖
> A决定B，B决定C，那么A间接决定C，也就是C传递依赖于A

## 价值与用途
> 如果没有规范，会存在这些问题：数据冗余、更新异常、插入异常、删除异常
> 但相对的，也没有必须严格遵守，需在时间成本和空间成本衡量

## 键
![[数据库系统-规范化理论-键]]

| 名称   | 定义 |
| ------ | ---- |
| 超键   | 多个属性组合而成的键，存在多余属性。比如学号+身份证号+姓名决定性别，但其实学号或身份证号就可以了，无须姓名，多余属性是姓名     |
| 候选键 | 在超键基础上，去除多余属性，比如学号+身份证号     |
| 主键   | 在候选键基础上，任选一个，比如学号或身份证号     |
| 外键   |      |

### 求候选键
> 用有向图+两个方法论，解答
> 人度为0的属性：没其它属性与其关联
> 出度为0的属性：没与其它属性关联

1. 将关系模式的函数依赖关系用“有向图”的方式表示
2. 找**入度为0**的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有结点，则该属性集即为关系模式的候选键
3. 若入度为0的属性集不能遍历图中所有结点，则需要尝试性的将一些中间结点(**既有入度，也有出度的结点**)并入入度为0的属性集中，直至该集合能遍历所有结点，集合为候选键

**题目**
![[Pasted image 20220328214007.png]]

**答案：A1、ABCD、A和B**

注意例2和例3，
例2是ABCD的组合键；
例3是使用第二个方法论，A和B都可

## 范式
> 结合[[#函数依赖]]和[[#求候选键]]
> 范式越高，数据粒度越小，意味着拆分成更多表，性能就越差
> 所以要平衡，一般到第三范式即可
![[数据库系统-规范化理论-范式]]


### 第一范式
> 只要属性可拆解，则不符合
> 比如高级职称个数，还可以拆分成教授和副教授

### 第二范式
> 在第一范式基础上
> 其他属性与主键中某个属性没有联系，则不符合（**也可以这么理解：当前表必须只描述一件事**）
> 比如课程名称跟学生成绩表在一起，主键是学号+课程id，那么课程名称与学号没有联系

### 第三范式
> 在第二范式基础上
> 其他属性与主键存在间接关联，则不符合
> 比如学生表，存在系信息（系名称和楼层），关系是学生由班级管理，班级由系管理，间接关联了

### 第四方式（BCNF）
[[重点]]
* **候选键中每个属性都是主属性**
> 设R是一个关系模型，R依赖于F，F中每个依赖项必须是R的候选键（候选码）

比如有向图：`SJ共同指向T，T和J互相指向`，候选键是SJ和ST，依赖关系是：`SJ->T，T->J`
，T这个依赖项并不是候选键，因此不符合


## 模式分解
### 保持函数依赖分解
> 关系模式R，设模式分解`p={R1,R2...,Rk}`，是关系模式R的一个分解；
> R={A,B,C}，函数依赖：A->B、B->C，A->C；
> 分解R1=(A,B)和R3=(A,C)，并不能保持函数依赖分解，因为缺少B->C
>  分解R1=(A,B)和R2=(B,C)，保持函数依赖分解，因为传递依赖：A->B->C

### 无损分解
> 拆分出来的关系模式，可以还原到拆解前的关系模式
> **具体来说就是，一个关系模式，按物理设计，拆分成多个表，然后关联多个表查询出来的数据，包含了关系模式的所有属性**，这就是无损，反之为有损


#### 无损联接分解
> 一个关系模式分解成若干个关系模式后，通过自然链接或投影等运算，仍能还原到原来的关系模式
* 判断是否无损联接分解的方法
1. 工作中的本能，通过属性是否能关联所有属性，满足关系模式
2. 表格列举法，将拆解的关系模式一个个放左侧，右侧每一列是所有属性的排列，标记处每个拆解关系模式是否有当前属性，标记过后，没有的属性，是否能通过标记为有的属性获得，最终只要有一个拆解关系模式包含所有属性，则是无损分解（其实是第一个方法，只是要画图）
3. 拆解关系模式的交集与，他们互相差集，是否包含给定的函数依赖
![[Pasted image 20220330204058.png]]


# 并发控制
![[数据库系统-并发控制]]   

### 事务

| 性质   | 描述 |
| ------ | ---- |
| 原子性 | 所有操作要么不做，要么都做     |
| 一致性 | 操作前的状态和操作后的状态是一致的（能力守恒），比如转账，操作前和操作后的总额是一样的     |
| 隔离性 | 事务之间是隔离的，互不影响，比如事务A对数据1更新，还没提交；事务2这时是看不到事务A更新的数据的    |
| 持续性       | 操作过后，数据是持久的     |

### 封锁协议
* **X锁为写锁，S锁为写锁**
* 封锁协议的引入，会导致死锁

| 协议     | 描述                                                                                                      |
| -------- | --------------------------------------------------------------------------------------------------------- |
| 一级封锁 | 事务在修改数据之前先加X锁（之后其它事务，不能再加锁），直到事务结束才释放，**防止丢失修改**               |
| 二级封锁 | 事务在读取数据之前加S锁（之后其它事务，可加读锁，不可加写锁），读取完即释放，**防止丢失修改、读取脏数据** |
| 三级封锁 | 在一级和二级基础上，加上读锁在事务结束后才释放这个限定条件，**防止丢失修改、读取脏数据，可重复读**        |
| 两段锁   | 可串行化，可能发生死锁                                                                                                          |

# 数据库完整性约束
> 保证数据完整，但只能应对简单情况
> 这时可以用触发器，应对复杂情况

| 类型                 | 描述                     |
| -------------------- | ------------------------ |
| 实体完整性约束       | 主键，不可为空，不可重复 |
| 参照完整性约束       | 外键，填入的内容必须是另一个表的主键中找得到或为空                         |
| 用户自定义完整性约束 | 比如不能为空，长度等                         |

# 数据库安全
| 措施           | 描述                                                                                                 |     |
| -------------- | ---------------------------------------------------------------------------------------------------- | --- |
| 用户标识和鉴定 | 最外层的安全保护措施，可以使用用户帐户、口令及随机数检验等方式                                       |     |
| 存取控制       | 按级别对yo农户授权，包括操作类型（如查找、插入、则除、修改等动作）和数据对象（主要是数据范围）的权限 |     |
| 密码存储和传输 | 对远程终端信息用密码传输                                                                             |     |
| 视图的保护     | 对视图进行授权,哪些用户可以修改，哪些用户可查看                                                      |     |
| 审计           | 使用一个专用文件或数据库，自动将用户对数据库的所有操作记录下来                                       |     |

# 数据库备份
| 方式   | 优点                                                                                                                                                                                        | 缺点                                                                                                                                                                                               |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 冷备份 | 非常快速的备份方法(只需复制文件)；容易归档(简单复制即可，比如以天为单位);容易恢复到某个某一时间点上(只需将文件再复制回去)；能与归档方法相结合，做数据库“最佳状态”的恢复；低度维护，高度安全 | 单独使用时，只能提供到的某个某一时间点上的恢复；在实施备份的全过程中，**数据库必须停掉**；**不支持压缩**，若磁盘空间有限，只能复制到磁带等其他外部存储设备上，速度会很慢；**不能按表或按用户恢复** |
| 热备份 | 可在表空间或数据库文件级备份，备份的时间短；**备份时数据库仍可使用**；可达到秒级恢复(恢复到某一时间点上；**可只对某个表或某个用户做恢复**；恢复是快速的                                     | 不能出错，否则后果严重:若热备份不成功；所得结果不可用于时间点的恢复；因难在于维护，所以要特别小心，不允许“以失败告终”                                                                              |

### 热备份
#### 备份类型
* 完全备份
	备份所有数据
* 差量备份
	仅备份上一次完全备份之后变化的数据
* 增量备份
	备份上一次备份之后变化的数据（完全备份或差量备份）

### 转储
* 静态海量转储
	在系统中无运行事务时进行，每次转储全部数据库。
* 静态增量转储
	在系统中无运行事务时进行，每次只转储上一次转储后更新过的数据。
* 动态海量转储
	转储期间，允许对数据库进行存取或修改，每次转储全部数据库。
* 动态增量转储
	转储期间，允许对数据库进行存取或修改，每次只转储上一次转储后更新过的数据。

### 实时备份（日志备份）
> 上面的方式是固定时刻备份，比如每天凌晨，假如还没到凌晨，数据库就出错了，那么就会丢失一天的数据
> 为了避免这个问题，可使用日志文件（详细每条数据的操作）
> 事务日志是针对数据库改变所做的记录，它可以记录针对数据库的任何操作，并将记录结果保存在独立的文件中

### 故障与恢复
| 故障                   | 原因                   | 解决                                                                   |
| ---------------------- | ---------------------- | ---------------------------------------------------------------------- |
| 事务本身的可预期故障   | 本身逻辑，比如长度过长 | 程序中设置Rollback语句                                                 |
| 事务本身的不可预期故障 | 算法溢出、违反存储保护 | 由DBMS的恢复子系统通过日志，撤销事务对数据库的修改，回退到事务初始状态 |
| 系统故障               | 系统停止运转           | 通常使用检查点法                                                       |
| 介质故障               | 外存被破坏             | 一般使用日志重做业务                                                   |

* **检查点法**
[[重点]]
[数据库恢复技术总结](https://baijiahao.baidu.com/s?id=1723255734080537809&wfr=spider&for=pc)
> 记录redo日志时，设置检查记录地址（相当于window系统的还原点），还原到之前某个时刻， 保证数据库能启动
![[Pasted image 20220331223905.png]]
# 分布式数据库

# 数据仓库与数据挖掘
## 数据库与数据仓库的区别
1. 数据库是面向业务的，比如费用数据，近期的数据才会用到，越来越多的数据，性能会下降，所以这时会采用删数据或拆表的方式。但其实这些数据是有用的，用于领导决策，所以可以将这些数据保存到数据仓库
2. 数据库是面向主题、集成的、相对稳定、反映历史变化
> 面向主题：需要哪些数据，就将相应的表拷贝一份
> 集成的：报表等统计类固化数据
> 相对稳定：不会更新、删除数据，都是查询
> 反映历史变化：报表数据的趋势

## 建立数据仓库的步骤
### 数据源的抽数
1. 抽取
2. 清理
	去除冗余；提高完整性、准确性等
3. 装载
	保存到数据仓库
4. 刷新
	更新数据仓库

### 建立数据集市
因为建立数据仓库，对企业风险蛮大，因此先建立数据集市，先从小规模数据开始，建立小规模数据库仓库，然后合并，形成最终的数据仓库

### OLAP服务器

### 顶层应用
1. 查询工具
2. 报表工具
3. 分析工具
4. 数据挖掘工具
...